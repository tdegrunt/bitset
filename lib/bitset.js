// Generated by CoffeeScript 1.6.2
(function() {
  var BitSet;

  module.exports = BitSet = (function() {
    var nextValueFrom;

    function BitSet() {
      this.bitsPerWord = 32;
      this.addressBitsPerWord = 5;
      this.store = [];
    }

    BitSet.prototype.wordIndex = function(pos) {
      return pos >> this.addressBitsPerWord;
    };

    BitSet.prototype.set = function(pos) {
      return this.store[this.wordIndex(pos - 1)] |= 1 << pos - 1;
    };

    BitSet.prototype.clear = function(pos) {
      return this.store[this.wordIndex(pos - 1)] &= 0xFF ^ (1 << pos - 1);
    };

    BitSet.prototype.get = function(pos) {
      return (this.store[this.wordIndex(pos - 1)] & (1 << pos - 1)) !== 0;
    };

    BitSet.prototype.length = function() {
      if (this.wordLength() === 0) {
        return 0;
      } else {
        return this.bitsPerWord * (this.wordLength() - 1) + (this.store[this.wordLength() - 1].toString(2).length + 1);
      }
    };

    BitSet.prototype.wordLength = function() {
      var length, pos, _i, _ref;

      length = this.store.length;
      for (pos = _i = _ref = this.store.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; pos = _ref <= 0 ? ++_i : --_i) {
        if (this.store[pos] !== 0) {
          break;
        }
        length--;
      }
      return length;
    };

    BitSet.prototype.store = function() {
      return this.store;
    };

    BitSet.prototype.cardinality = function() {
      var pos, sum, _i, _ref;

      sum = 0;
      for (pos = _i = 0, _ref = this.length(); 0 <= _ref ? _i <= _ref : _i >= _ref; pos = 0 <= _ref ? ++_i : --_i) {
        if (this.get(pos)) {
          sum++;
        }
      }
      return sum;
    };

    BitSet.prototype.toString = function() {
      var pos, result, _i, _ref;

      result = [];
      for (pos = _i = 0, _ref = this.length(); 0 <= _ref ? _i <= _ref : _i >= _ref; pos = 0 <= _ref ? ++_i : --_i) {
        if (this.get(pos)) {
          result.push(pos);
        }
      }
      return "{" + (result.join(",")) + "}";
    };

    BitSet.prototype.toBinaryString = function() {
      var lpad,
        _this = this;

      lpad = function(str, padString, length) {
        while (str.length < length) {
          str = padString + str;
        }
        return str;
      };
      if (this.wordLength() > 0) {
        return this.store.map(function(word) {
          return lpad(word.toString(2), '0', _this.bitsPerWord);
        }).join('');
      } else {
        return lpad('', 0, this.bitsPerWord);
      }
    };

    BitSet.prototype.or = function(set) {
      var pos, wordsInCommon, _i, _ref;

      if (this === set) {
        return;
      }
      wordsInCommon = Math.min(this.wordLength(), set.wordLength());
      for (pos = _i = 0, _ref = wordsInCommon - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; pos = 0 <= _ref ? ++_i : --_i) {
        this.store[pos] |= set.store[pos];
      }
      if (wordsInCommon < set.wordLength()) {
        this.store = this.store.concat(set.store.slice(wordsInCommon, set.wordLength()));
      }
      return null;
    };

    BitSet.prototype.and = function(set) {
      var pos, _i, _j, _ref, _ref1, _ref2;

      if (this === set) {
        return;
      }
      for (pos = _i = _ref = this.wordLength, _ref1 = set.wordLength(); _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; pos = _ref <= _ref1 ? ++_i : --_i) {
        this.store[pos] = 0;
      }
      for (pos = _j = 0, _ref2 = this.wordLength(); 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; pos = 0 <= _ref2 ? ++_j : --_j) {
        this.store[pos] &= set.store[pos];
      }
      return null;
    };

    BitSet.prototype.andNot = function(set) {
      var pos, _i, _ref;

      for (pos = _i = 0, _ref = Math.min(this.wordLength(), set.wordLength) - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; pos = 0 <= _ref ? ++_i : --_i) {
        this.store[pos] &= ~set.store[pos];
      }
      return null;
    };

    BitSet.prototype.xor = function(set) {
      var pos, _i, _ref;

      if (this === set) {
        return;
      }
      for (pos = _i = 0, _ref = this.wordLength(); 0 <= _ref ? _i <= _ref : _i >= _ref; pos = 0 <= _ref ? ++_i : --_i) {
        this.store[pos] ^= set.store[pos];
      }
      return null;
    };

    BitSet.prototype.isEmpty = function() {
      return this.length() === 0;
    };

    BitSet.prototype.nextSetBit = function(fromIndex) {
      return nextValueFrom.call(this, true, fromIndex, 1);
    };

    BitSet.prototype.nextClearBit = function(fromIndex) {
      return nextValueFrom.call(this, false, fromIndex, 1);
    };

    BitSet.prototype.previousSetBit = function(fromIndex) {
      return nextValueFrom.call(this, true, fromIndex, -1);
    };

    BitSet.prototype.previousClearBit = function(fromIndex) {
      return nextValueFrom.call(this, false, fromIndex, -1);
    };

    nextValueFrom = function(value, from, increment, maxIndex) {
      var check, pos;

      check = null;
      pos = from;
      while (pos >= 0 && pos <= this.bitsPerWord) {
        pos += increment;
        check = this.get(pos);
        if (check === value) {
          return pos;
        }
      }
      return null;
    };

    return BitSet;

  })();

}).call(this);
